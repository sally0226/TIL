
## [#1 의도하지 않은 variable shadowing](https://100go.co/#unintended-variable-shadowing-1)

TL;DR
>  variable shadowing을 피하면, 잘못된 변수를 참조하는 등의 실수를 줄일 수 있다.

variable shadowing : 내부 블록에서 같은 이름의 변수를 재선언할 때 발생 
에러의 경우 err과 같은 변수 이름을 재사용하는 것이 편리할 수 있지만, 일반적인 경우에는 피하는 것이 좋다. 변수의 값이 예상한 것과 다를 수 있기 때문이다.


## [#2 불필요하게 중첩된 코드](https://100go.co/#unnecessary-nested-code-2)

TL;DR
>가독성을 위해 중첩을 최소화 하는 것이 좋다.  가독성을 높이는 것은 중요하다.
else 블록을 사용하는 경우는 없어야 한다.

- not good
```
if foo() {
	return true
} else {
	// ...
}
```
- good
```
if foo() {
	return true
}
// ...
```

반대로 else 안에서 return이 이루어진다면, 조건을 반대로 수정해서 else 블록을 없앤다.
- not good
```
if s != "" {
	// ...
} else {
	return errors.New("empty string")
}
```
- good
```
if s == "" {
	return errors.New("empty string")
}
// ...
```

## [#3 init 함수 잘못 사용하기](https://100go.co/#misusing-init-functions-3)
TL;DR
> 변수를 초기화할 때, init 함수보다 직접 작성한 초기화용 함수로 처리되는 것이 더 적합한 경우가 대부분이다.
> init 함수는 에러처리가 제한되어 있으며, 상태 처리 및 테스트가 더 복잡하다

init 함수는 파라미터를 사용하지 않고, return값도 없다. (func()) 

문제점
- 에러 관리 제한
- 테스트 구현 방법이 복잡해짐
- 초기화를 위해 상태설정이 필요할 경우, 전역변수 이용해야 함
	- 파라미터가 없기 때문

static 값들을 설정하는 등의 일부 상황에서는 init이 도움될 수 있으나, 대부분의 경우 그렇지 않다.

## #4 getter & setter 남용
TL;DR
> Go에서는 getter, setter를 강제로 사용하는 것이 일반적이지 않다.

데이터 캡슐화 : 객체의 값이나 상태를 숨기는 것
getter, setter는 필드에 대한 exported 메소드를 제공하여 캡슐화를 활성화하는 수단이다.

Go에서는 getter, setter에 대한 자동 지원이 없다.
또한 getter, setter를 사용하는 것이 필수도 아니고 일반적이지도 않은 것으로 간주된다.

Go는 단순성을 포함한 다양한 특성을 위해 설계된 고유한 언어라는 것을 기억해라.
그러나 getter, setter의 필요성을 찾게 되거나, 향후 호환성을 보장하면서 필요성을 예측하는 경우 사용하는데 문제는 없다. (???)

## [#5 Interface 오염](https://100go.co/#interface-pollution-5)
TL;DR
> 추상화는 만들어지는 것이 아니라 발견되어야 한다.
> 불필요한 복잡성을 방지하기 위해, 필요할 때 인터페이스를 생성해라.
> 최소한 추상화가 유효하다는 것을 입증할 수 있을 때 인터페이스를 생성해라

Interface : 객체의 동작을 지정하는 방법을 제공
Go의 Interface가 다른 언어와 다른 점은 암묵적으로 구현된다는 점이다. (명시적인 키워드를 통해 구현되지 않는다)

interface가 가치있는 세가지 사례
- 공통 동작 뽑아내기
- 디커플링을 생성하고 ??
- 타입을 특정 행동으로 제한

대부분의 경우 추상화를 위해 interface가 만들어진다.
그리고 주의해야 할 점은, 추상화를 만드는 것이 아니라 발견해야 한다는 점이다.
-> 즉각적인 이유가 없다면, 추상화 생성을 시작하지 말라는 것

interface를 과도하게 사용할 경우 문제점
- 코드 흐름을 복잡하게 만든다
- 쓸모없는 수준의 간접 참조를 추가해도 아무런 가치가 없다

구현을 직접 호출하는건 어떨까요?

> 롭파이크 - Don’t design with interfaces, discover them.

interface가 코드에 어떤 도움이 되는지 확실하지 않다면, 코드를 더 단순하게 만들기 위해 interface 제거를 고려해야 할 것이다.


## [#6 생산자 측 인터페이스 정의 피하기](https://100go.co/#interface-on-the-producer-side-6)
TL;DR
> 호출하는 쪽(클라이언트) 에서 인터페이스를 유지하면 불필요한 추상화가 방지된다.

Go에서 인터페이스는 암시적으로 구현된다.
추상화는 생성되는 것이 아니라 발견되어야 하는 것이기 때문에,
모든 클라이언트에 대해 특정 추상화를 강제하는 것이 생산자의 몫이 아니라는 것을 의미한다.

가장 적합한 추상화 수준을 결정하는 것은 클라이언트의 몫이다.

대부분의 경우 인터페이스는 소비자 측에 있어야 한다.
그러나 특정 경우에 생산자측에서 갖고싶을 수도 있다. 그럴 때는 가능한한 최소화 하여 재사용성을 높이고 쉽게 구성할 수 있도록 노력해야 한다. 

사용하는 쪽에서 내가 필요한 최소한의 추상화를 구성해서 사용하는 것이 좋다.

## [#7 Interface 반환](https://100go.co/#returning-interfaces-7)
TL;DR
> 함수는 대부분의 경우 인터페이스가 아닌 구체적인 구현을 반환해야 한다.
> 반대로 함수는 인자로 인터페이스를 허용하는 것이 좋다
> (반환은 구체적인 구현으로, 인자는 인터페이스로)

함수가 인터페이스를 반환할 경우 단점
- 패키지 종속성으로 인해 디자인이 복잡해짐
- 모든 클라이언트가 동일한 추상화에 의존해야 함 -> 유연성 제한

추상화가 클라이언트에 도움이 될 것이라는걸 알고있는 경우 인터페이스를 반환하는 것을 고려할 수 있다. (이런 경우가 아니면 최대한 인터페이스 반환하지 마라)

클라이언트가 추상화 할 수 있으니까 필요하더라도 클라이언트가 하게 둬라

#### 적용 방향?
현재 우리는 New~~ 함수가 전부 인터페이스를 리턴하는데 이것을 구조체 리턴으로 바꾸고
해당 함수를 사용하는 쪽에서 인터페이스 타입으로 사용하도록 하기

## [#8 `any` 는 아무것도 의미하지 않는다](https://100go.co/#any-says-nothing-8)
TL;DR
> json.Marshal과 같이 가능한 유형을 받거나 반환해야 하는 경우에만 any를 사용해라 
> any는 의미 있는 정보를 제공하지 않는다.
> 호출자가 모든 데이터 타입의 메소드를 호출할 수 있게 해서, 컴파일 시간이 오래걸릴 수 있다.

일반적으로 우리는 코드를 과도하게 일반화 하는 것을 피해야 한다. 
과도하게 일반화 하는 것 보다 약간의 중복된 코드가 더 나을 수도 있다.

## [#9 제네릭을 언제 사용해야 하는가?](https://100go.co/#being-confused-about-when-to-use-generics-9)
TL;DR
> 제네릭을 잘못 사용하면 불필요한 추상화와 복잡성이 발생할 수 있다. 

https://100go.co/9-generics/

제네릭은 새로 추가된 개념이다. 즉, 나중에 필요할 때 제네릭을 사용하도록 변경할 수 있다. 

